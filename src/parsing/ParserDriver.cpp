#include "trx/parsing/ParserDriver.h"

#include "trx/diagnostics/DiagnosticEngine.h"

#include <fstream>
#include <sstream>
#include <string>

// Forward declarations generated by Flex/Bison
struct yy_buffer_state;
using YY_BUFFER_STATE = yy_buffer_state *;

int yyparse(trx::parsing::ParserDriver &driver, void *scanner);
int yylex_init_extra(trx::parsing::ParserDriver *driver, void **scanner);
void yylex_destroy(void *scanner);
YY_BUFFER_STATE yy_scan_bytes(const char *bytes, int len, void *scanner);
void yy_delete_buffer(YY_BUFFER_STATE buffer, void *scanner);
void yyset_debug(int, void *scanner);

extern int yylex(trx::parsing::ParserDriver *driver, void *scanner);

namespace trx::parsing {

ParserDriver::ParserDriver()
    : context_{diagnostics_} {}

bool ParserDriver::parseFile(const std::filesystem::path &path) {
    std::ifstream input(path);
    if (!input.is_open()) {
        diagnostics_.report(diagnostics::Diagnostic::Level::Error,
                            "Unable to open input file",
                            {.file = path.string(), .line = 0, .column = 0});
        return false;
    }

    std::ostringstream buffer;
    buffer << input.rdbuf();
    const std::string content = buffer.str();
    return parseImpl(content, path.string());
}

bool ParserDriver::parseString(std::string_view input, std::string_view virtualFile) {
    return parseImpl(input, virtualFile);
}

ParserContext &ParserDriver::context() noexcept {
    return context_;
}

const diagnostics::DiagnosticEngine &ParserDriver::diagnostics() const noexcept {
    return diagnostics_;
}

void ParserDriver::setCurrentFile(std::string_view fileName) {
    currentFile_.assign(fileName.begin(), fileName.end());
}

std::string_view ParserDriver::currentFile() const noexcept {
    return currentFile_;
}

bool ParserDriver::parseImpl(std::string_view content, std::string_view fileName) {
    void *scanner = nullptr;
    if (yylex_init_extra(this, &scanner) != 0) {
        diagnostics_.report(diagnostics::Diagnostic::Level::Error,
                            "Failed to initialise lexer",
                            {.file = std::string(fileName), .line = 0, .column = 0});
        return false;
    }

    yyset_debug(0, scanner);
    setCurrentFile(fileName);

    YY_BUFFER_STATE buffer = yy_scan_bytes(content.data(), static_cast<int>(content.size()), scanner);

    const int result = yyparse(*this, scanner);

    context_.finalize();

    yy_delete_buffer(buffer, scanner);
    yylex_destroy(scanner);

    return result == 0 && !diagnostics_.hasErrors();
}

} // namespace trx::parsing
