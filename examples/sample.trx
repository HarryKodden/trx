// TRX Sample - PERSON Entity CRUD Operations
// Demonstrates REST API implementation using TRX grammar

// Define the PERSON record type mapped to the database table
// TYPE PERSON FROM TABLE person;

// Initialize database with sample data
EXPORT METHOD POST FUNCTION init_person_table() : JSON {
    EXEC SQL DROP TABLE IF EXISTS person;
    EXEC SQL CREATE TABLE person (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        age INTEGER,
        active BOOLEAN DEFAULT TRUE,
        salary DECIMAL(10,2)
    );

    // Insert sample data
    EXEC SQL INSERT INTO person (id, name, age, active, salary) VALUES
        (1, 'Alice Johnson', 30, TRUE, 75000.00),
        (2, 'Bob Smith', 25, TRUE, 50000.00),
        (3, 'Charlie Brown', 35, FALSE, 60000.00);
    
    RETURN { "status": "initialized" };
}

// GET /debug_persons - Debug: show all persons with IDs
EXPORT METHOD GET FUNCTION debug_persons() : JSON {
    VAR result JSON := { "persons": [] };

    EXEC SQL DECLARE debug_cursor CURSOR FOR SELECT id, name, age, active, salary FROM person;
    EXEC SQL OPEN debug_cursor;
    WHILE sqlcode = 0 {
        VAR person JSON := {};
        EXEC SQL FETCH debug_cursor INTO :person.id, :person.name, :person.age, :person.active, :person.salary;
        if sqlcode = 0 {
            append(result.persons, person);
        }
    }
    EXEC SQL CLOSE debug_cursor;
    
    RETURN result;
}

// GET /persons - Retrieve all persons
EXPORT METHOD GET FUNCTION persons() : JSON {
    VAR person FROM TABLE person;
    VAR result JSON := { "persons": [] };

    VAR count INTEGER;
    EXEC SQL DECLARE persons CURSOR FOR SELECT id, name, age, active, salary FROM person;
    EXEC SQL OPEN persons;
    WHILE sqlcode = 0 {
        EXEC SQL FETCH persons INTO :person.id, :person.name, :person.age, :person.active, :person.salary;
        if sqlcode = 0 {
            append(result.persons, person);
        }
    }
    EXEC SQL CLOSE persons;
    
    RETURN result;
}

// GET /person/{id} - Retrieve a specific person by ID
EXPORT METHOD GET FUNCTION person/{id: INTEGER}() : JSON {
    VAR person FROM TABLE person;
    
    EXEC SQL DECLARE person_cursor CURSOR FOR SELECT id, name, age, active, salary FROM person WHERE id = :id;
    EXEC SQL OPEN person_cursor;
    EXEC SQL FETCH person_cursor INTO :person.id, :person.name, :person.age, :person.active, :person.salary;
    
    IF sqlcode = 100 {
        EXEC SQL CLOSE person_cursor;
        THROW "person not found";
    }
    
    EXEC SQL CLOSE person_cursor;
    RETURN person;
}

// POST /persons - Create a new person
EXPORT METHOD POST FUNCTION persons(person_data: JSON) : JSON {
    VAR new_id INTEGER;
    VAR name STRING := person_data.name;
    VAR age INTEGER := person_data.age;
    VAR active BOOLEAN := person_data.active;
    VAR salary DECIMAL := person_data.salary;

    // Insert the new person
    EXEC SQL INSERT INTO person (name, age, active, salary) VALUES (:name, :age, :active, :salary);

    // Get the auto-generated ID (assuming SQLite auto-increment)
    EXEC SQL DECLARE id_cursor CURSOR FOR SELECT last_insert_rowid();
    EXEC SQL OPEN id_cursor;
    EXEC SQL FETCH id_cursor INTO :new_id;
    EXEC SQL CLOSE id_cursor;

    RETURN {
        "id": new_id,
        "name": name,
        "age": age,
        "active": active,
        "salary": salary,
        "message": "Person created successfully"
    };
}

// PUT /person/{id} - Update an existing person
EXPORT METHOD PUT FUNCTION person/{id: INTEGER}(person_data: JSON) : JSON {
    VAR person_id INTEGER := id;
    VAR name STRING := person_data.name;
    VAR age INTEGER := person_data.age;
    VAR active BOOLEAN := person_data.active;
    VAR salary DECIMAL := person_data.salary;

    // Check if person exists
    VAR exists_check INTEGER;
    EXEC SQL DECLARE exists_cursor CURSOR FOR SELECT 1 FROM person WHERE id = :person_id;
    EXEC SQL OPEN exists_cursor;
    EXEC SQL FETCH exists_cursor INTO :exists_check;

    IF sqlcode = 100 {
        EXEC SQL CLOSE exists_cursor;
        RETURN {"error": "Person not found", "id": person_id};
    }

    EXEC SQL CLOSE exists_cursor;

    // Update the person
    EXEC SQL UPDATE person SET name = :name, age = :age, active = :active, salary = :salary WHERE id = :person_id;

    RETURN {
        "id": person_id,
        "name": name,
        "age": age,
        "active": active,
        "salary": salary,
        "message": "Person updated successfully"
    };
}

// DELETE /person/{id} - Delete a person
EXPORT METHOD DELETE FUNCTION person/{id: INTEGER}() : JSON {
    VAR person_id INTEGER := id;

    // Check if person exists
    VAR exists_check INTEGER;
    EXEC SQL DECLARE exists_cursor CURSOR FOR SELECT 1 FROM person WHERE id = :person_id;
    EXEC SQL OPEN exists_cursor;
    EXEC SQL FETCH exists_cursor INTO :exists_check;

    IF sqlcode = 100 {
        EXEC SQL CLOSE exists_cursor;
        RETURN {"error": "Person not found", "id": person_id};
    }

    EXEC SQL CLOSE exists_cursor;

    // Delete the person
    EXEC SQL DELETE FROM person WHERE id = :person_id;

    RETURN {
        "id": person_id,
        "message": "Person deleted successfully"
    };
}
